package org.seasar.doma.jdbc.query;

import static org.seasar.doma.internal.util.AssertionUtil.assertEquals;
import static org.seasar.doma.internal.util.AssertionUtil.assertNotNull;

import java.lang.reflect.Method;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.ListIterator;
import org.seasar.doma.internal.jdbc.entity.AbstractPostInsertContext;
import org.seasar.doma.internal.jdbc.entity.AbstractPreInsertContext;
import org.seasar.doma.internal.jdbc.sql.PreparedSqlBuilder;
import org.seasar.doma.jdbc.Config;
import org.seasar.doma.jdbc.JdbcException;
import org.seasar.doma.jdbc.Naming;
import org.seasar.doma.jdbc.PreparedSql;
import org.seasar.doma.jdbc.SqlKind;
import org.seasar.doma.jdbc.dialect.Dialect;
import org.seasar.doma.jdbc.entity.EntityPropertyType;
import org.seasar.doma.jdbc.entity.EntityType;
import org.seasar.doma.jdbc.entity.GeneratedIdPropertyType;
import org.seasar.doma.jdbc.entity.Property;
import org.seasar.doma.jdbc.id.IdGenerationConfig;
import org.seasar.doma.jdbc.id.ReservedIdProvider;
import org.seasar.doma.message.Message;

public class AutoBatchUpsertQuery<ENTITY> extends AutoBatchModifyQuery<ENTITY>
    implements BatchInsertQuery {
  protected GeneratedIdPropertyType<ENTITY, ?, ?> generatedIdPropertyType;

  protected IdGenerationConfig idGenerationConfig;

  protected boolean batchSupported = true;

  protected boolean generatedKeysIgnored = false;
  private BatchUpdateQueryHelper<ENTITY> updateHelper;
  private DuplicateKeyType duplicateKeyType;

  public AutoBatchUpsertQuery(EntityType<ENTITY> entityType) {
    super(entityType);
  }

  public void setGeneratedKeysIgnored(boolean generatedKeysIgnored) {
    this.generatedKeysIgnored = generatedKeysIgnored;
  }

  @Override
  public void prepare() {
    super.prepare();
    assertNotNull(method, entities, sqls);
    int size = entities.size();
    if (size == 0) {
      return;
    }
    currentEntity = entities.get(0);
    preUpsert();
    prepareIdAndVersionPropertyTypes();
    prepareOptions();
    prepareTargetPropertyTypes();
    prepareIdValue();
    prepareVersionValue();
    prepareSql();
    entities.set(0, currentEntity);
    for (ListIterator<ENTITY> it = entities.listIterator(1); it.hasNext(); ) {
      currentEntity = it.next();
      preUpsert();
      prepareIdValue();
      prepareVersionValue();
      prepareSql();
      it.set(currentEntity);
    }
    currentEntity = null;
    assertEquals(entities.size(), sqls.size());
  }

  protected void preUpsert() {
    AutoBatchPreUpsertContext<ENTITY> context =
        new AutoBatchPreUpsertContext<>(entityType, method, config, duplicateKeyType);
    entityType.preInsert(currentEntity, context);
    if (context.getNewEntity() != null) {
      currentEntity = context.getNewEntity();
    }
  }

  @Override
  protected void prepareIdAndVersionPropertyTypes() {
    super.prepareIdAndVersionPropertyTypes();
    generatedIdPropertyType = entityType.getGeneratedIdPropertyType();
    if (generatedIdPropertyType != null) {
      if (idGenerationConfig == null) {
        idGenerationConfig =
            new IdGenerationConfig(
                config, entityType, new ReservedIdProvider(config, entityType, entities.size()));
        generatedIdPropertyType.validateGenerationStrategy(idGenerationConfig);
        autoGeneratedKeysSupported =
            !generatedKeysIgnored
                && generatedIdPropertyType.isAutoGeneratedKeysSupported(idGenerationConfig);
        batchSupported =
            generatedKeysIgnored || generatedIdPropertyType.isBatchSupported(idGenerationConfig);
      }
    }
  }

  protected void prepareTargetPropertyTypes() {
    targetPropertyTypes = new ArrayList<>(entityType.getEntityPropertyTypes().size());
    for (EntityPropertyType<ENTITY, ?> propertyType : entityType.getEntityPropertyTypes()) {
      //      if (!propertyType.isUpsertable()) {
      if (!propertyType.isInsertable()) {
        continue;
      }
      if (propertyType.isId()) {
        if (propertyType != generatedIdPropertyType
            || generatedIdPropertyType.isIncluded(idGenerationConfig)) {
          targetPropertyTypes.add(propertyType);
        }
        if (generatedIdPropertyType == null) {
          Property<ENTITY, ?> property = propertyType.createProperty();
          property.load(currentEntity);
          if (property.getWrapper().get() == null) {
            throw new JdbcException(Message.DOMA2020, entityType.getName(), propertyType.getName());
          }
        }
        continue;
      }
      if (!isTargetPropertyName(propertyType.getName())) {
        continue;
      }
      targetPropertyTypes.add(propertyType);
    }
    completeTargetPropertyTypes();
  }

  private void completeTargetPropertyTypes() {
    if (!targetPropertyTypes.isEmpty()) {
      executable = true;
      sqlExecutionSkipCause = null;
    }
  }

  protected void prepareIdValue() {
    if (generatedIdPropertyType != null && idGenerationConfig != null) {
      currentEntity =
          generatedIdPropertyType.preInsert(entityType, currentEntity, idGenerationConfig);
    }
  }

  protected void prepareVersionValue() {
    if (versionPropertyType != null) {
      currentEntity = versionPropertyType.setIfNecessary(entityType, currentEntity, 1);
    }
  }

  protected void prepareSql() {
    Naming naming = config.getNaming();
    Dialect dialect = config.getDialect();
    PreparedSqlBuilder builder = new PreparedSqlBuilder(config, SqlKind.BATCH_UPSERT, sqlLogType);
    UpsertContext context =
        UpsertContext.fromEntity(
            builder,
            entityType,
            duplicateKeyType,
            naming,
            dialect,
            idPropertyTypes,
            targetPropertyTypes,
            currentEntity);
    UpsertBuilder upsertBuilderQuery = dialect.getUpsertBuilder(context);
    upsertBuilderQuery.build();
    PreparedSql sql = builder.build(this::comment);
    sqls.add(sql);
  }

  @Override
  public boolean isBatchSupported() {
    return batchSupported;
  }

  @Override
  public void generateId(Statement statement, int index) {
    if (generatedIdPropertyType != null && idGenerationConfig != null) {
      ENTITY newEntity =
          generatedIdPropertyType.postInsert(
              entityType, entities.get(index), idGenerationConfig, statement);
      entities.set(index, newEntity);
    }
  }

  @Override
  public void complete() {
    for (ListIterator<ENTITY> it = entities.listIterator(); it.hasNext(); ) {
      currentEntity = it.next();
      postUpsert();
      it.set(currentEntity);
    }
  }

  public void setDuplicateKeyType(DuplicateKeyType duplicateKeyType) {
    this.duplicateKeyType = duplicateKeyType;
  }

  protected void postUpsert() {
    AutoBatchPostUpsertContext<ENTITY> context =
        new AutoBatchPostUpsertContext<>(entityType, method, config, duplicateKeyType);
    entityType.postInsert(currentEntity, context);
    if (context.getNewEntity() != null) {
      currentEntity = context.getNewEntity();
    }
  }

  protected static class AutoBatchPreUpsertContext<E> extends AbstractPreInsertContext<E> {

    private final DuplicateKeyType duplicateKeyType;

    public AutoBatchPreUpsertContext(
        EntityType<E> entityType, Method method, Config config, DuplicateKeyType duplicateKeyType) {
      super(entityType, method, config);
      this.duplicateKeyType = duplicateKeyType;
    }

    public java.util.Optional<DuplicateKeyType> getDuplicateKeyType() {
      return java.util.Optional.of(duplicateKeyType);
    }
  }

  protected static class AutoBatchPostUpsertContext<E> extends AbstractPostInsertContext<E> {

    private final DuplicateKeyType duplicateKeyType;

    public AutoBatchPostUpsertContext(
        EntityType<E> entityType, Method method, Config config, DuplicateKeyType duplicateKeyType) {
      super(entityType, method, config);
      this.duplicateKeyType = duplicateKeyType;
    }

    public java.util.Optional<DuplicateKeyType> getDuplicateKeyType() {
      return java.util.Optional.of(duplicateKeyType);
    }
  }
}
